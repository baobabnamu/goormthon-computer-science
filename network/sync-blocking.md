# Sync & Async, Blocking & Non Blocking에 대해서 ✅

# Sync와 Async

![image.png](Sync%20&%20Async,%20Blocking%20&%20Non%20Blocking%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%20%E2%9C%85%2020118fdf38ed80419c69c70bbb5e3b6c/image.png)

- **동기(Synchronous) : 작업을 요청한 뒤, 작업 종료 시점까지 대기 → 작업 순서가 보장됨.**
- **비동기(Asynchronous) : 작업 종료 시점을 기다리지 않고 작업을 요청하게 돼 순서가 보장되지 않음.**
- **순서 보장**

# Blocking과 Non-Blocking

![image.png](Sync%20&%20Async,%20Blocking%20&%20Non%20Blocking%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%20%E2%9C%85%2020118fdf38ed80419c69c70bbb5e3b6c/image%201.png)

- **블로킹(Blocking) : 작업을 요청한 함수가 완료될 때까지 제어권을 상대에게 넘기고, 호출한 쪽은 멈춤**
- **논블로킹(Non-Blocking) : 작업을 요청해도 제어권을 넘기지 않고 호출한 쪽에서 작업을 계속 이어감 (논블로킹은 제어권을 주고 받지 않고, 독립적으로 갖고 있음.)**
- **작업 제어권**

### 논블로킹은 한정적인 리소스에서 유용하다.

- 자신이 처리할 요청은 꾸준히 제어권을 가지고 진행하고, 나머지는 외부에 요청하는 등 효율적인 작업 처리 가능.
- 단일 코어로도 마치 다중 처리(병렬 처리)가 가능한 것처럼 동시성을 보장함.

![image.png](Sync%20&%20Async,%20Blocking%20&%20Non%20Blocking%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%20%E2%9C%85%2020118fdf38ed80419c69c70bbb5e3b6c/image%202.png)

- 심지어 논블로킹으로 구축한 다음 클러스터링 하면, 동시성과 병렬성을 보장할 수 있음.
- **블로그에 흔히 나와있는 병렬적으로 처리한다라는 말은 틀린 말임.**

# 유사한 개념과 관점의 차이

- 두 기술은 엄연히 다른 기술이다.
- **왜 헷갈릴까?** 
→ ‘기다리는’ 개념 (Synchronous, Blocking) 
→ ‘안 기다리는’ 개념 (Asynchronous, Non-Blocking)

- **어떤 점에 집중해야할까?**
    
    동기/비동기 그룹은 ***작업 순서***에, 블로킹/논블로킹 그룹은 ***제어권***에 초점을 둠.
    

## 두 개념은 독립적이지만, 밀접한 관계가 있어 같이 사용된다.

![image.png](Sync%20&%20Async,%20Blocking%20&%20Non%20Blocking%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%20%E2%9C%85%2020118fdf38ed80419c69c70bbb5e3b6c/image%203.png)

| **조합** | **실행 순서(작업 순서)** | **제어권(컨트롤)** |
| --- | --- | --- |
| **Sync + Blocking** | 작업을 순차적으로, 앞의 작업이 끝나야 다음 작업 시작 | 호출한 쪽이 결과를 받을 때까지 제어권을 넘기고 기다림 |
| **Sync + Non-Blocking** | 작업을 순차적으로, 결과를 직접 확인(폴링 등) 후 다음 작업 | 호출한 쪽이 제어권을 계속 가짐, 직접 상태를 반복 확인 |
| **Async + Blocking** | 작업 순서는 보장하지 않으나, 각 작업은 완료될 때까지 대기 | 호출한 쪽이 제어권을 넘기고, 완료 신호(콜백 등)까지 기다림 |
| **Async + Non-Blocking** | 작업 순서와 무관, 여러 작업이 동시에 독립적으로 진행 | 호출한 쪽이 즉시 제어권을 받고, 완료 시 콜백/이벤트로 결과 전달 |

### 여전히 이해가 안 되셨다면? 제가 예제를 만들어왔어요.

**[파일 시스템 작업]**

- Sync + Blocking 조합 : 파일시스템에 접근해서 특정 파일을 수정하는 등, 작업 간의 순서가 보장되어야 하고, interrupt에 민감할 때 사용

**[Node.js 의 상황]**

- Async + Blocking 조합 : Node.js 에서 MySQL Connection (1:1 매핑) 사용 시 한 번에 하나의 쿼리만 처리할 수 있어 Async + Non Blocking 하게 요청을 보내도 MySQL 의 종속성으로 인해 Sync + Blocking 하게 처리되어 최종적으로는 Async + Blocking 하게 처리됨

**[브라우저 내부 동작]**

- Sync + Non-Blocking : 클라이언트(브라우저)는 UI 상태를 sync + non-blocking 방식으로 관리해 즉각적인 반응성과 부드러운 사용자 경험을 제공
- Async + Non-Blocking : 서버와의 데이터 통신은 async + non-blocking 방식으로 처리해 네트워크 지연이나 서버 처리 시간에 상관없이 앱을 동작 시킴